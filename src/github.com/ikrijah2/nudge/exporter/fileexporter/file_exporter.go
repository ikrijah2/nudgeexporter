// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package fileexporter

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strconv"
	"sync"
	"time"

	"github.com/gogo/protobuf/jsonpb"
	proto "github.com/gogo/protobuf/proto"

	"github.com/ikrijah2/nudge/test"
	googleproto "google.golang.org/protobuf/proto"

	"github.com/ikrijah2/nudge/component"
	"github.com/ikrijah2/nudge/consumer/pdata"
	"github.com/ikrijah2/nudge/internal"
)

var marshaler = &jsonpb.Marshaler{}

// Marshaler configuration used for marhsaling Protobuf to JSON. Use default config.

var spanCount int

// fileExporter is the implementation of file exporter that writes telemetry data to a file
// in Protobuf-JSON format.
type fileExporter struct {
	file  io.WriteCloser
	mutex sync.Mutex
}

type AutoGenerated struct {
	ResourceSpans []struct {
		Resource struct {
			Attributes []struct {
				Key   string `json:"key"`
				Value struct {
					StringValue string `json:"stringValue"`
				} `json:"value"`
			} `json:"attributes"`
		} `json:"resource"`
		InstrumentationLibrarySpans []struct {
			InstrumentationLibrary struct {
				Name string `json:"name"`
			} `json:"instrumentationLibrary"`
			Spans []struct {
				TraceID           string `json:"traceId"`
				SpanID            string `json:"spanId"`
				ParentSpanID      string `json:"parentSpanId"`
				Name              string `json:"name"`
				Kind              string `json:"kind"`
				StartTimeUnixNano string `json:"startTimeUnixNano"`
				EndTimeUnixNano   string `json:"endTimeUnixNano"`
				Events            []struct {
					TimeUnixNano string `json:"timeUnixNano"`
					Name         string `json:"name"`
				} `json:"events,omitempty"`
				Status struct {
				} `json:"status"`
				Attributes []struct {
					Key   string `json:"key"`
					Value struct {
						StringValue string `json:"stringValue"`
					} `json:"value"`
				} `json:"attributes,omitempty"`
			} `json:"spans"`
		} `json:"instrumentationLibrarySpans"`
	} `json:"resourceSpans"`
}

func (e *fileExporter) ConsumeTraces(_ context.Context, td pdata.Traces) error {
	spanCount = td.SpanCount()
	//fmt.Printf("nombres de spans %v", td.SpanCount())

	return exportMessageAsLine(e, internal.TracesToOtlp(td.InternalRep()))
}

func (e *fileExporter) ConsumeMetrics(_ context.Context, md pdata.Metrics) error {
	return exportMessageAsLine(e, internal.MetricsToOtlp(md.InternalRep()))
}

func (e *fileExporter) ConsumeLogs(_ context.Context, ld pdata.Logs) error {
	request := internal.LogsToOtlp(ld.InternalRep())
	return exportMessageAsLine(e, request)
}

func exportMessageAsLine(e *fileExporter, message proto.Message) error {
	// Ensure only one write operation happens at a time.
	e.mutex.Lock()
	defer e.mutex.Unlock()

	// e.file correspond au nom donné dans config.yml lors du lancement d'otel collector.
	// Serialisation du message protobuf en JSON. (écriture d'une ligne JSON dans le file)
	if err := marshaler.Marshal(e.file, message); err != nil {
		return err
	}

	// Permet de mettre les valeurs du JSON de sortie basique du fileexporter dans la struct Autogenerated.
	// Cette manière permet d'accéder aux values en faisant par exemple :
	// traces.ResourceSpans[0].InstrumentationLibrarySpans[0].Spans[0].StartTimeUnixNano

	var traces AutoGenerated

	var buf bytes.Buffer

	// Marshal serializes a protobuf message as JSON into buf.
	if err := marshaler.Marshal(&buf, message); err != nil {
		return err
	}

	var str = buf.String()

	// Unmarshal unmarshals a JSON object from []byte(str) into &traces.
	if err := json.Unmarshal([]byte(str), &traces); err != nil {
		return err
	}

	// Population de AutoGenerated terminé

	// Utilisation du rawdata.pb.go
	var rawdata = test.RawData{}

	// Population des données à partir du Autogenerated dans le Rawdata
	JSONtoRawdata(traces, &rawdata)
	//
	// Write the new address rawdata to file.
	out, err := googleproto.Marshal(&rawdata)
	if err != nil {
		log.Fatalln("Failed to encode address book:", err)
	}
	if err := ioutil.WriteFile("fname", out, 0644); err != nil {
		log.Fatalln("Failed to write address book:", err)
	}
	//
	//

	// Read the existing rawdata file.
	in, err := ioutil.ReadFile("fname")
	if err != nil {
		log.Fatalln("Error reading file:", err)
	}
	rawdataUnmarshal := test.RawData{}
	if err := googleproto.Unmarshal(in, &rawdataUnmarshal); err != nil {
		log.Fatalln("Failed to parse address book:", err)
	}
	var m = int(*rawdataUnmarshal.Id)
	fmt.Printf("id lecture unmarshal  %v \n AgentID : %v \n", m, *rawdataUnmarshal.AgentId)

	SendRawdataToNudge()

	if _, err := io.WriteString(e.file, "\n"); err != nil {
		return err
	}
	return nil
}

func (e *fileExporter) Start(context.Context, component.Host) error {
	return nil
}

// Shutdown stops the exporter and is invoked during shutdown.
func (e *fileExporter) Shutdown(context.Context) error {
	return e.file.Close()
}

func JSONtoRawdata(t AutoGenerated, rawdata *test.RawData) {

	var str *string
	itest := "122ffeb4-46ec-4564-a0d6-f952ac014787"
	uuid := t.ResourceSpans[0].Resource.Attributes[1].Value.StringValue
	uuidPtr := &uuid
	str = &itest

	// idRawdata correspond au nombre de spans (champ id du rawdata.proto)
	idRawdata := int64(spanCount)
	var idRawDataPointer *int64 = &idRawdata

	rawdata.Id = idRawDataPointer
	rawdata.AgentId = str

    NudgeVersion := "3.7.0"
    NudgeVersionPtr := &NudgeVersion


    var availableProcessors int32 = int32(1)
    availableProcessorsPtr := &availableProcessors

    var ServerConfig test.ServerConfig
    var JvmInfoPtr *test.JvmInfo
    var JvmInfo test.JvmInfo
    var SystemProperties []*test.KeyValue
    var SystemPropertiesKeyValue test.KeyValue
    sysKey := "test"
    sysValue := "ceci est une value"
    sysKeyPtr := &sysKey
    sysValuePtr := &sysValue
    SystemPropertiesKeyValue.Key = sysKeyPtr
    SystemPropertiesKeyValue.Value = sysValuePtr
    SystemPropertiesPtr := &SystemPropertiesKeyValue
    SystemProperties = append(SystemProperties, SystemPropertiesPtr)

    HostName := "otelcol"
    HostNamePtr := &HostName
    JvmInfo.HostName = HostNamePtr
    JvmInfo.SystemProperties = SystemProperties
    JvmInfoPtr = &JvmInfo

    ServerConfig.NudgeVersion = NudgeVersionPtr
    ServerConfig.AvailableProcessors = availableProcessorsPtr
    ServerConfig.VmName = HostNamePtr
    ServerConfig.JvmInfo = JvmInfoPtr
    SrvPtr := &ServerConfig

    rawdata.ServerConfig = SrvPtr

	// Ajout données de l'instrumentation dotnet Sample.Client
	// dans /data/opentelemetry-dotnet/opentelemetry-dotnet/examples/Console/InstrumentationWithActivitySource.cs

	var Transactions []*test.Transaction
	var ExtendedCodes []*test.KeyValue

	for k, v := range t.ResourceSpans[0].InstrumentationLibrarySpans[1].Spans {

		var compteur int32 = int32(k + 1)
		compteurPtr := &compteur

		var Transaction test.Transaction
		Url := v.Name
		TxType := v.Kind
		Code := v.Name
		UseragentID := int32(0)

		var StartTimePointer *int64 = TimeToInt64(v.StartTimeUnixNano)
		var EndTimePointer *int64 = TimeToInt64(v.EndTimeUnixNano)
		var UrlPointer *string = &Url
		var TxTypePointer *string = &TxType
		var CodePointer *string = &Code
		var UseragentIDPtr *int32 = &UseragentID

		Transaction.StartTime = StartTimePointer
		Transaction.EndTime = EndTimePointer
		Transaction.Url = UrlPointer
		Transaction.TxType = TxTypePointer
		Transaction.Code = CodePointer
		Transaction.Uuid = uuidPtr
		Transaction.UrlID = compteurPtr
		Transaction.UseragentID = UseragentIDPtr

		// Faire la même chose avec EndTime

		for _, attr := range v.Attributes {
			var ExtendedCodePtr *test.KeyValue
			var ExtendedCode test.KeyValue

			//
			keyString := attr.Key
			var keyStringPointeur *string = &keyString
			ExtendedCode.Key = keyStringPointeur

			//
			valueString := attr.Value.StringValue
			var valueStringPointeur *string = &valueString
			ExtendedCode.Value = valueStringPointeur

			ExtendedCodePtr = &ExtendedCode
			ExtendedCodes = append(ExtendedCodes, ExtendedCodePtr)

		}

		Transaction.ExtendedCodes = ExtendedCodes

		// On créé le pointeur qui va pointer sur Transaction
		var TransactionPtr *test.Transaction
		TransactionPtr = &Transaction

		// On ajoute la Transaction dans le tableau des Transactions
		Transactions = append(Transactions, TransactionPtr)

	}


	rawdata.Transactions = Transactions

}

func SendRawdataToNudge() {

	file, _ := os.Open("fname") // changer le nom du file ?

	defer file.Close()

	r, _ := http.NewRequest("PUT", "http://localhost:8080/nudge-war/collect/rawdata/122ffeb4-46ec-4564-a0d6-f952ac014787", file)
	r.Header.Set("Content-Type", "text/pain")
	client := &http.Client{}
	client.Do(r)

}

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// Fonctions pour optimiser le code

// Fonction qui prend la donnée de temps du JSON du fileexporter (string), par exemple, StartTimeUnixNano.
// convertit ce temps de nanosecondes en millisecondes.
// et place le résultat dans un pointeur int64
func TimeToInt64(v string) *int64 {
	// Conversion string -> int64 (on a du Time Unix Nanosecond)
	TimeInt64, err := strconv.ParseInt(v, 10, 64)

	if err != nil {
		fmt.Printf("%d of type %T", TimeInt64, TimeInt64)
	}

	// on converti le Time Unix Nanosecond en Time Unix Millisecond
	epochMs := int64(TimeInt64) / (int64(time.Millisecond)/int64(time.Nanosecond))

	// Mise en place dans un pointeur
	var StartTimePointer *int64 = &epochMs

	return StartTimePointer

}


//
//
//
//
//
//
