// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package fileexporter

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	//"io/ioutil"
	"os"
	"strconv"
	"sync"
	"mime/multipart"
	"net/http"

	"github.com/gogo/protobuf/jsonpb"
	"github.com/gogo/protobuf/proto"

	"github.com/ikrijah2/nudge/component"
	"github.com/ikrijah2/nudge/consumer/pdata"
	"github.com/ikrijah2/nudge/internal"
)

// Marshaler configuration used for marhsaling Protobuf to JSON. Use default config.
var marshaler = &jsonpb.Marshaler{}

var spanCount int

// fileExporter is the implementation of file exporter that writes telemetry data to a file
// in Protobuf-JSON format.
type fileExporter struct {
	file  io.WriteCloser
	mutex sync.Mutex
}

type AutoGenerated struct {
	ResourceSpans []struct {
		Resource struct {
			Attributes []struct {
				Key   string `json:"key"`
				Value struct {
					StringValue string `json:"stringValue"`
				} `json:"value"`
			} `json:"attributes"`
		} `json:"resource"`
		InstrumentationLibrarySpans []struct {
			InstrumentationLibrary struct {
				Name string `json:"name"`
			} `json:"instrumentationLibrary"`
			Spans []struct {
				TraceID           string `json:"traceId"`
				SpanID            string `json:"spanId"`
				ParentSpanID      string `json:"parentSpanId"`
				Name              string `json:"name"`
				Kind              string `json:"kind"`
				StartTimeUnixNano string `json:"startTimeUnixNano"`
				EndTimeUnixNano   string `json:"endTimeUnixNano"`
				Events            []struct {
					TimeUnixNano string `json:"timeUnixNano"`
					Name         string `json:"name"`
				} `json:"events,omitempty"`
				Status struct {
				} `json:"status"`
				Attributes []struct {
					Key   string `json:"key"`
					Value struct {
						StringValue string `json:"stringValue"`
					} `json:"value"`
				} `json:"attributes,omitempty"`
			} `json:"spans"`
		} `json:"instrumentationLibrarySpans"`
	} `json:"resourceSpans"`
}

func (e *fileExporter) ConsumeTraces(_ context.Context, td pdata.Traces) error {
	spanCount = td.SpanCount()
	//fmt.Printf("nombres de spans %v", td.SpanCount())

	return exportMessageAsLine(e, internal.TracesToOtlp(td.InternalRep()))
}

func (e *fileExporter) ConsumeMetrics(_ context.Context, md pdata.Metrics) error {
	return exportMessageAsLine(e, internal.MetricsToOtlp(md.InternalRep()))
}

func (e *fileExporter) ConsumeLogs(_ context.Context, ld pdata.Logs) error {
	request := internal.LogsToOtlp(ld.InternalRep())
	return exportMessageAsLine(e, request)
}

func exportMessageAsLine(e *fileExporter, message proto.Message) error {
	// Ensure only one write operation happens at a time.
	e.mutex.Lock()
	defer e.mutex.Unlock()

	if err := marshaler.Marshal(e.file, message); err != nil {
		return err
	}

	var traces AutoGenerated

	var buf bytes.Buffer

	if err := marshaler.Marshal(&buf, message); err != nil {
		return err
	}

	var str = buf.String()

	// decoding traceswrapper struct
	// from json format
	err := json.Unmarshal([]byte(str), &traces)

	if err != nil {

		// if error is not nil
		// print error
		return err
	}

	file, err := JSONtoRawdata(traces)
	if err != nil {
		return err
	}

	fmt.Print(file)


	//SendRawdataToLocalServer()


	//fmt.Printf("json output ==> %v\n", traces.ResourceSpans[0].InstrumentationLibrarySpans[0].Spans[0].StartTimeUnixNano)



	if _, err := io.WriteString(e.file, "\n"); err != nil {
		return err
	}
	return nil
}

func (e *fileExporter) Start(context.Context, component.Host) error {
	return nil
}

// Shutdown stops the exporter and is invoked during shutdown.
func (e *fileExporter) Shutdown(context.Context) error {
	return e.file.Close()
}

// Transformation du JSON en un format type rawdata
func JSONtoRawdata(t AutoGenerated) (*os.File, error) {

	// si le fichier n'existe pas, on le créé
	//  et si le fichier existe, on prend les 2 premieres lignes.
	// si les 2 premieres lignes sont egales au json alors on peut reprendre le meme fichier

	_, e := os.Stat("newfile.txt")
	if os.IsNotExist(e) {
		fmt.Print("erreur file does not exist")

		str := `id: ` + strconv.Itoa(spanCount) + `
agentId: "` + t.ResourceSpans[0].Resource.Attributes[1].Value.StringValue + `"`

		file, err := os.Create("newfile.txt")
		if err != nil {
			fmt.Print("erreur lors de la creation du file")
		}
		_, err = file.WriteString(str)
		return file, err
	}

	fileOpener, err := os.Open("newfile.txt")

	scanner := bufio.NewScanner(fileOpener)

	var lineCount = 0
	var stringfile string
	
	for scanner.Scan() {
		line := scanner.Text()
		stringfile = stringfile + line

		lineCount++

		if lineCount == 2 {
			break
		}
	}

	AddSpanTimeToRawdata(t)


	// si les 2 premieres lignes du JSON (nouvelle Trace) 
	// et les 2 premieres lignes du fichier déjà existant sont egaux
	
	//result1 := str == stringfile

	// si c'est la même "sonde", on ajoute les nouvelles données 
	//directement dans le fichier précédent

	return fileOpener, err
}

func AddSpanTimeToRawdata(t AutoGenerated) {


	file, err := os.OpenFile("newfile.txt", os.O_APPEND|os.O_WRONLY, 0600)

	for k, v := range t.ResourceSpans[0].InstrumentationLibrarySpans[1].Spans {
		str:="\nTransaction {"
		str = str + "\n  startTime: " + v.StartTimeUnixNano + "\n  endTime: " + v.EndTimeUnixNano
		for _, attr := range v.Attributes {
			str = str + "\n  params {\n" 
			str = str +  "    key: " + `"` + attr.Key + `"` + "\n"
			str = str +  "    value: " + `"` + attr.Value.StringValue + `"` + "\n  }" 
			fmt.Printf("value de l'attribute: %v \n", attr.Value)
		}
		str = str + "\n}"
		fmt.Printf("value de la key %v et spanid \n", k, v.SpanID)
		_, err = file.WriteString(str)
		if err!=nil{
			fmt.Printf("erreur écriture Spans \n")
		}
	}
	defer file.Close()


}


func SendRawdataToNudgeServer(){

	file, _ := os.Open("newfile.txt")
	defer file.Close()

	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	part, _ := writer.CreateFormFile("file", "newfile.txt")
	io.Copy(part, file)
	writer.Close()

	r, _ := http.NewRequest("POST", "https://{domain}/collect/rawdata/{token}", body)
	r.Header.Add("Content-Type", writer.FormDataContentType())
	client := &http.Client{}
	client.Do(r)


}

// func SendRawdataToLocalServer(){

// 	// Créér un UUID
// 	// Créer un serveur local pour tester la réception des requêtes 
// 	// Envoi requête POST 
// 	mux := http.NewServeMux()

// 	mux.HandleFunc("/upload", uploadFile)

// 	go func() {
// 		fmt.Println(" ECOUTE SUR LE PORT 8080 !!!!")
// 		http.ListenAndServe(":8080", mux)
// 	}()

// }

// func uploadFile(w http.ResponseWriter, r *http.Request){
// 	fmt.Fprintf(w, "Uploading file\n")

// 	r.ParseMultipartForm(10 << 20)

// 	file, handler, err := r.FormFile("myFile")

// 	if err !=nil {
// 		fmt.Println("Error pour retrouver le fichier depuis le form-data")
// 		fmt.Println(err)
// 		return
// 	}

// 	defer file.Close()

// 	fmt.Printf("\n\n\nUploaded file : %+v\n", handler.Filename)

// 	tempFile, err := ioutil.TempFile("temp-rawdata", "upload-*.txt")
// 	if err!=nil {
// 		fmt.Println(err)
// 		return
// 	}
// 	defer tempFile.Close()

// 	fileBytes, err := ioutil.ReadAll(file)
// 	if err !=nil {
// 		fmt.Println(err)
// 	}

// 	tempFile.Write(fileBytes)

// 	fmt.Println("Sucess!!!!!!!!!!!!!!\n")
// }


// curl -F 'myFile=@test.txt' http://localhost:8080/upload