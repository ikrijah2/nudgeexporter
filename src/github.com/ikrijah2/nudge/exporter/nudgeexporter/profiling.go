package nudgeexporter

import (
	"io/ioutil"
	"log"
	"strconv"
	"strings"

	"github.com/ikrijah2/nudge/rawdata"
)

type Class struct {
	name    string
	classId int32
}

type Method struct {
	name     string
	methodId int32
}

var listClass []*Class
var listMethod []*Method
var counterClassId = int32(0)
var counterMethodId = int32(0)

func stackTracetoRawdata(traces AutoGenerated, rd *rawdata.RawData) {

	uuid, err := ioutil.ReadFile("uuid")
	if err != nil {
		log.Fatalln("Error reading file:", err)
	}

	uuidPtr := PtrCreateAndAssign(string(uuid))

	var threadInfos []*rawdata.ThreadInfo

	var threadInfo rawdata.ThreadInfo

	var Frames []*rawdata.ThreadInfo_StackTraceElement

	var isInListClass bool = false
	var isInListMethod bool = false

	var BlockedCount *int64
	var BlockedTime *int64
	var WaitedCount *int64
	var WaitedTime *int64

	var classDictionary *rawdata.Dictionary = &rawdata.Dictionary{}
	var methodDictionary *rawdata.Dictionary = &rawdata.Dictionary{}

	var entriesClass []*rawdata.Dictionary_DictionaryEntry
	var entriesMethod []*rawdata.Dictionary_DictionaryEntry

	for _, v := range traces.ResourceSpans[0].InstrumentationLibrarySpans {

		threadInfo.Uuid = uuidPtr

		if v.InstrumentationLibrary.Name == "Samples.Profiling" {

			var ClassName *string
			var MethodName *string
			var LineNumber *int32
			var ClassNameId *int32
			var MethodNameId *int32

			// State is RUNNABLE
			var state rawdata.ThreadInfo_State = 1
			var statePtr *rawdata.ThreadInfo_State = &state
			threadInfo.State = statePtr

			BlockedCount = PtrInt64CreateAndAssign(int64(200))
			WaitedCount = PtrInt64CreateAndAssign(int64(80000))
			BlockedTime = PtrInt64CreateAndAssign(int64(-1))
			WaitedTime = PtrInt64CreateAndAssign(int64(-1))

			threadInfo.BlockedCount = BlockedCount
			threadInfo.WaitedCount = WaitedCount
			threadInfo.BlockedTime = BlockedTime
			threadInfo.WaitedTime = WaitedTime

			for _, v2 := range v.Spans {

				var TimeStamp *int64

				TimeStamp = TimeToInt64(v2.StartTimeUnixNano)

				threadInfo.TimeStamp = TimeStamp

				for _, v3 := range v2.Attributes {
					var Frame rawdata.ThreadInfo_StackTraceElement

					var slice []string
					slice = strings.Split(v3.Value.StringValue, ";")
					if !(len(slice) < 3) {
						classNameStr := slice[0]
						methodNameStr := slice[1]
						lineNumberStr := slice[2]

						lineNumberInt64, _ := strconv.ParseInt(lineNumberStr, 10, 32)

						lineNumberInt32 := int32(lineNumberInt64)

						ClassName = PtrCreateAndAssign(classNameStr)
						MethodName = PtrCreateAndAssign(methodNameStr)
						LineNumber = PtrInt32CreateAndAssign(lineNumberInt32)

						Frame.ClassName = ClassName
						Frame.MethodName = MethodName
						Frame.LineNumber = LineNumber

						// pour l'ID des classes

						for _, value := range listClass {
							// si la classe est dans la liste, on prend l'id correspondant
							if value.name == classNameStr {
								ClassNameIdValue := value.classId
								ClassNameId = &ClassNameIdValue
								isInListClass = true
								break
							}
							isInListClass = false
						}

						// sinon on ajoute la classe dans la liste
						if isInListClass == false {
							class := Class{name: classNameStr, classId: counterClassId}
							ClassNameId = &class.classId
							classPtr := &class

							listClass = append(listClass, classPtr)
							counterClassId++
						}

						// pour l'ID des mÃ©thodes

						for _, value2 := range listMethod {
							// si la classe est dans la liste, on prend l'id correspondant
							if value2.name == methodNameStr {
								MethodNameIdValue := value2.methodId
								MethodNameId = &MethodNameIdValue
								isInListMethod = true
								break
							}
							isInListMethod = false
						}

						// sinon on ajoute la classe dans la liste
						if isInListMethod == false {
							method := Method{name: methodNameStr, methodId: counterMethodId}
							MethodNameId = &method.methodId
							methodPtr := &method

							listMethod = append(listMethod, methodPtr)
							counterMethodId++
						}

						Frame.ClassNameId = ClassNameId
						Frame.MethodNameId = MethodNameId

						// TODO REINITIALISER LES COMPTEURS

						var FramePtr *rawdata.ThreadInfo_StackTraceElement

						FramePtr = &Frame

						Frames = append(Frames, FramePtr)
					}

				}

			}
		}
	}

	var lastClassname = listClass[len(listClass)-1]
	var lastMethod = listMethod[len(listMethod)-1]
	str := lastClassname.name + "." + lastMethod.name

	var UrlPtr *string = PtrCreateAndAssign(str)

	threadInfo.Url = UrlPtr

	for _, valueClass := range listClass {
		var entry rawdata.Dictionary_DictionaryEntry
		var entryPtr *rawdata.Dictionary_DictionaryEntry

		classid := valueClass.classId
		classidPtr := &classid
		entry.Id = classidPtr
		classname := valueClass.name
		classnamePtr := &classname
		entry.Name = classnamePtr

		entryPtr = &entry
		entriesClass = append(entriesClass, entryPtr)
	}

	classDictionary.Dictionary = entriesClass
	rd.ClassDictionary = classDictionary

	for _, valueMethod := range listMethod {
		var entry rawdata.Dictionary_DictionaryEntry
		var entryPtr *rawdata.Dictionary_DictionaryEntry

		entryid := valueMethod.methodId
		entryidPtr := &entryid
		entry.Id = entryidPtr
		entryname := valueMethod.name
		entrynamePtr := &entryname
		entry.Name = entrynamePtr

		entryPtr = &entry
		entriesMethod = append(entriesMethod, entryPtr)
	}

	methodDictionary.Dictionary = entriesMethod
	rd.MethodDictionary = methodDictionary

	threadInfo.Frames = Frames

	var threadInfoPtr *rawdata.ThreadInfo
	threadInfoPtr = &threadInfo

	threadInfos = append(threadInfos, threadInfoPtr)

	rd.ThreadInfos = threadInfos

	WriteAddRawdata(rd)
}
