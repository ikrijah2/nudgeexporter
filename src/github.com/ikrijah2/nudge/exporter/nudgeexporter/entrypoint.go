package nudgeexporter

import (
	"fmt"
	"io/ioutil"
	"log"
	"strconv"
	"time"

	"github.com/ikrijah2/nudge/rawdata"
)

type AutoGenerated struct {
	ResourceSpans []struct {
		Resource struct {
			Attributes []struct {
				Key   string `json:"key"`
				Value struct {
					StringValue string `json:"stringValue"`
				} `json:"value"`
			} `json:"attributes"`
		} `json:"resource"`
		InstrumentationLibrarySpans []struct {
			InstrumentationLibrary struct {
				Name string `json:"name"`
			} `json:"instrumentationLibrary"`
			Spans []struct {
				TraceID           string `json:"traceId"`
				SpanID            string `json:"spanId"`
				ParentSpanID      string `json:"parentSpanId"`
				Name              string `json:"name"`
				Kind              string `json:"kind"`
				StartTimeUnixNano string `json:"startTimeUnixNano"`
				EndTimeUnixNano   string `json:"endTimeUnixNano"`
				Attributes        []struct {
					Key   string `json:"key"`
					Value struct {
						IntValue    string `json:"intValue,omitempty"`
						StringValue string `json:"stringValue,omitempty"`
					} `json:"value"`
				} `json:"attributes"`
				Status struct {
				} `json:"status,omitempty"`
			} `json:"spans"`
		} `json:"instrumentationLibrarySpans"`
	} `json:"resourceSpans"`
}

func entryPoint(traces AutoGenerated, rd *rawdata.RawData) {

	fmt.Println("Debug nudge")
	baseData(traces, rd)

	for _, span := range traces.ResourceSpans[0].InstrumentationLibrarySpans[0].Spans {
		switch typeofSpan := span.Name; typeofSpan {
		case "http-request":
			fmt.Println("http request")
			httpToRawdata(traces, rd)
		case "sql-server.query":
			fmt.Println("sql query")
			sqlToRawdata(traces, rd)
		default:
		}
	}
}

// TODO A REECRIRE
// Données de base à mettre dans le rawdata
func baseData(traces AutoGenerated, rd *rawdata.RawData) {
	uuid, err := ioutil.ReadFile("uuid")
	if err != nil {
		log.Fatalln("Error reading file:", err)
	}

	uuidStr := string(uuid)
	uuidPtr := &uuidStr

	// idRawdata correspond au nombre de spans (champ id du rawdata.proto)
	idRawdata := int64(spanCount)
	var idRawDataPtr *int64 = &idRawdata

	rd.Id = idRawDataPtr
	rd.AgentId = uuidPtr

	NudgeVersionPtr := PtrCreateAndAssign("3.4.0")

	// informations de config customisable
	var ServerConfig rawdata.ServerConfig
	var JvmInfoPtr *rawdata.JvmInfo
	var JvmInfo rawdata.JvmInfo
	var SystemProperties []*rawdata.KeyValue
	var SystemPropertiesKeyValue rawdata.KeyValue
	sysKey := "rawdata"
	sysValue := "ceci est une value"
	sysKeyPtr := &sysKey
	sysValuePtr := &sysValue
	SystemPropertiesKeyValue.Key = sysKeyPtr
	SystemPropertiesKeyValue.Value = sysValuePtr
	SystemPropertiesPtr := &SystemPropertiesKeyValue
	SystemProperties = append(SystemProperties, SystemPropertiesPtr)

	HostName := "otelcol"
	HostNamePtr := &HostName
	JvmInfo.HostName = HostNamePtr
	JvmInfo.SystemProperties = SystemProperties
	JvmInfoPtr = &JvmInfo

	ServerConfig.NudgeVersion = NudgeVersionPtr
	ServerConfig.JvmInfo = JvmInfoPtr
	SrvPtr := &ServerConfig

	rd.ServerConfig = SrvPtr
}

//

// UTIL

// créé un pointeur de type string et assigne la value
func PtrCreateAndAssign(value string) *string {
	var valuePtr *string
	valuePtr = &value
	return valuePtr
}

func TimeToInt64(v string) *int64 {
	// Conversion string -> int64 (on a du Time Unix Nanosecond)
	TimeInt64, err := strconv.ParseInt(v, 10, 64)

	if err != nil {
		fmt.Printf("%d of type %T", TimeInt64, TimeInt64)
	}

	// on converti le Time Unix Nanosecond en Time Unix Millisecond
	epochMs := int64(TimeInt64) / (int64(time.Millisecond) / int64(time.Microsecond))

	// Mise en place dans un pointeur
	var TimePointer *int64 = &epochMs

	return TimePointer
}
