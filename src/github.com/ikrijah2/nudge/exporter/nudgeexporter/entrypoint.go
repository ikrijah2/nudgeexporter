package nudgeexporter

import (
	"fmt"
	"io/ioutil"
	"log"
	"math"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/ikrijah2/nudge/rawdata"

	googleproto "google.golang.org/protobuf/proto"
)

type AutoGenerated struct {
	ResourceSpans []struct {
		Resource struct {
			Attributes []struct {
				Key   string `json:"key"`
				Value struct {
					StringValue string `json:"stringValue"`
				} `json:"value"`
			} `json:"attributes"`
		} `json:"resource"`
		InstrumentationLibrarySpans []struct {
			InstrumentationLibrary struct {
				Name string `json:"name"`
			} `json:"instrumentationLibrary"`
			Spans []struct {
				TraceID           string `json:"traceId"`
				SpanID            string `json:"spanId"`
				ParentSpanID      string `json:"parentSpanId"`
				Name              string `json:"name"`
				Kind              string `json:"kind"`
				StartTimeUnixNano string `json:"startTimeUnixNano"`
				EndTimeUnixNano   string `json:"endTimeUnixNano"`
				Attributes        []struct {
					Key   string `json:"key"`
					Value struct {
						IntValue    string `json:"intValue,omitempty"`
						StringValue string `json:"stringValue,omitempty"`
					} `json:"value"`
				} `json:"attributes"`
				Status struct {
				} `json:"status,omitempty"`
			} `json:"spans"`
		} `json:"instrumentationLibrarySpans"`
	} `json:"resourceSpans"`
}

var url string = "/"

func entryPoint(traces AutoGenerated, rd *rawdata.RawData) {

	baseData(traces, rd)

	for i := len(traces.ResourceSpans[0].InstrumentationLibrarySpans[0].Spans) - 1; i >= 0; i-- {
		if strings.HasPrefix(traces.ResourceSpans[0].InstrumentationLibrarySpans[0].Spans[i].Name, "aspnet") {
			fmt.Println("aspnet !")
			httpToRawdata(traces.ResourceSpans[0].InstrumentationLibrarySpans[0].Spans[i], rd)
			stackTracetoRawdata(traces, rd)
		} else if strings.HasPrefix(traces.ResourceSpans[0].InstrumentationLibrarySpans[0].Spans[i].Name, "sql") {
			fmt.Println("sql query")
			sqlToRawdata(traces.ResourceSpans[0].InstrumentationLibrarySpans[0].Spans[i], rd)
		} else {
			fmt.Println("error : trace wrong format")
		}
	}
}

// Données de base à mettre dans le rawdata
func baseData(traces AutoGenerated, rd *rawdata.RawData) {
	uuid, err := ioutil.ReadFile("uuid")
	if err != nil {
		log.Fatalln("Error reading file:", err)
	}

	uuidStr := string(uuid)
	uuidPtr := &uuidStr

	// idRawdata correspond au nombre de spans (champ id du rawdata.proto)
	idRawdata := int64(spanCount)
	var idRawDataPtr *int64 = &idRawdata

	// TODO change to trace resource name
	rd.Hostname = PtrCreateAndAssign("Krijah")

	rd.Id = idRawDataPtr
	rd.AgentId = uuidPtr

	NudgeVersionPtr := PtrCreateAndAssign("3.7.0")

	// informations de config customisable
	var ServerConfig rawdata.ServerConfig
	var JvmInfoPtr *rawdata.JvmInfo
	var JvmInfo rawdata.JvmInfo

	ServerName := PtrCreateAndAssign("Test-iptissame")

	ServerConfig.ServerName = ServerName
	JvmInfo.HostName = PtrCreateAndAssign("otelcol")
	JvmInfoPtr = &JvmInfo

	ServerConfig.NudgeVersion = NudgeVersionPtr
	ServerConfig.JvmInfo = JvmInfoPtr
	SrvPtr := &ServerConfig

	rd.ServerConfig = SrvPtr
}

//

// UTIL

// créé un pointeur de type string et assigne la value
func PtrCreateAndAssign(value string) *string {
	var valuePtr *string
	valuePtr = &value
	return valuePtr
}

func PtrInt32CreateAndAssign(value int32) *int32 {
	var valuePtr *int32
	valuePtr = &value
	return valuePtr
}

func PtrInt64CreateAndAssign(value int64) *int64 {
	var valuePtr *int64
	valuePtr = &value
	return valuePtr
}

func TimeToInt64(v string) *int64 {
	// Conversion string -> int64 (on a du Time Unix Nanosecond)
	TimeInt64, err := strconv.ParseInt(v, 10, 64)

	if err != nil {
		fmt.Printf("%d of type %T", TimeInt64, TimeInt64)
	}

	// on converti le Time Unix Nanosecond en Time Unix Millisecond
	epochMs := int64(TimeInt64) / (int64(time.Millisecond) / int64(time.Microsecond))

	// Mise en place dans un pointeur
	var TimePointer *int64 = &epochMs

	return TimePointer
}

func TimeToFloat64(v string) *int64 {
	// Conversion string -> int64 (on a du Time Unix Nanosecond)
	TimeInt64, err := strconv.ParseInt(v, 10, 64)

	if err != nil {
		fmt.Printf("%d of type %T", TimeInt64, TimeInt64)
	}

	// on converti le Time Unix Nanosecond en Time Unix Millisecond
	epochMs := int64(TimeInt64) / (int64(time.Millisecond) / int64(time.Microsecond))

	float := float64(epochMs)

	timestamp := math.Trunc(float/math.Pow(10, 5)) * math.Pow(10, 5)

	timestampint := int64(timestamp)

	var TimePointer *int64

	TimePointer = &timestampint

	return TimePointer
}

func WriteAddRawdata(rd *rawdata.RawData) {
	// Encode and write rawdata to file rawdata.dat
	in, err := googleproto.Marshal(rd)
	if err != nil {
		log.Fatalln("Failed to encode rawdata:", err)
	}

	f, err := os.OpenFile("rawdata.dat", os.O_APPEND|os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		log.Fatalln("Failed to write rawdata:", err)
	}

	defer f.Close()

	if _, err = f.WriteString(string(in)); err != nil {
		log.Fatalln("Failed to write rawdata:", err)
	}
}
